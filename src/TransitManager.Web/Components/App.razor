<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <base href="/" />
    <link rel="stylesheet" href="bootstrap/bootstrap.min.css" />
    <link rel="stylesheet" href="app.css" />
    <link rel="stylesheet" href="TransitManager.Web.styles.css" />
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css"
    <link rel="icon" type="image/png" href="favicon.png" />
    <HeadOutlet @rendermode="RenderMode.InteractiveServer" />
    <script>
        // Gestion du chargement et de la reconnexion - DÃ©finition anticipÃ©e
        console.log("ðŸ”„ [Script] DÃ©marrage de l'initialisation Blazor...");
        window.showBlazorApp = function() {
            try {
                var loading = document.getElementById('app-loading');
                var app = document.getElementById('blazor-app');
                // VÃ©rifier que les Ã©lÃ©ments existent (le DOM peut ne pas Ãªtre prÃªt si appelÃ© trop tÃ´t, mais Blazor appelera aprÃ¨s render)
                if(loading) loading.style.display = 'none';
                if(app) app.style.display = 'block';
            } catch (error) {
                console.error("âŒ [Script] Erreur lors de l'affichage:", error);
            }
        };
        
        // Timeout de sÃ©curitÃ©
        setTimeout(function() { 
            if(document.getElementById('app-loading') && document.getElementById('app-loading').style.display !== 'none') {
                window.showBlazorApp(); 
            }
        }, 3000);

        // Auto-reconnexion observer (doit attendre le body)
        document.addEventListener("DOMContentLoaded", function() {
             new MutationObserver((mutations, observer) => {
                if (document.querySelector('#components-reconnect-modal h5')) {
                    console.log("âš ï¸ DÃ©connexion dÃ©tectÃ©e. Rechargement...");
                     async function attemptReload() {
                        await new Promise(r => setTimeout(r, 2000));
                        location.reload();
                    }
                    attemptReload();
                }
            }).observe(document.body, { childList: true, subtree: true });
        });
    </script>
</head>
<body>
    <!-- Chargement initial -->
    <div id="app-loading">
        <div class="loading-container">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Chargement de l'application...</span>
            </div>
            <p class="mt-2">ðŸš€ Initialisation de TransitManager...</p>
        </div>
    </div>

    <!-- L'application Blazor -->
    <div id="blazor-app" style="display: none;">
        <Routes @rendermode="RenderMode.InteractiveServer" />
    </div>

	<script src="_framework/blazor.server.js"></script>
	
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="js/chartHelper.js"></script>
    <script>
        window.renderChart = (canvasId, type, data, options) => {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            
            // Destroy existing chart if any
             if (window[canvasId + '_chart']) {
                window[canvasId + '_chart'].destroy();
            }

            window[canvasId + '_chart'] = new Chart(ctx, {
                type: type,
                data: data,
                options: options
            });
        }
    </script>
    
    <!-- Le script doit Ãªtre ici -->
    <script>
        window.downloadFileFromStream = async (fileName, contentStreamReference) => {
            const arrayBuffer = await contentStreamReference.arrayBuffer();
            const blob = new Blob([arrayBuffer]);
            const url = URL.createObjectURL(blob);
            
            const anchorElement = document.createElement('a');
            anchorElement.href = url;
            anchorElement.download = fileName ?? '';
            anchorElement.click();
            anchorElement.remove();
            URL.revokeObjectURL(url);
        }

        window.triggerClick = (id) => {
            const el = document.getElementById(id);
            if(el) el.click();
        }
    </script>
    <!-- === FIN AJOUT === -->

    <!-- Script moved to head -->
	

    <script>
        window.signaturePad = {
            init: function (canvasId) {
                var canvas = document.getElementById(canvasId);
                if (!canvas) return;

                var ctx = canvas.getContext('2d');
                var isDrawing = false;
                var lastX = 0;
                var lastY = 0;

                // Ajuster la taille du canvas au conteneur
                function resizeCanvas() {
                    var parent = canvas.parentElement;
                    if (parent) {
                        canvas.width = parent.clientWidth;
                        // Hauteur fixe ou relative
                        if(canvas.height === 0 || canvas.height === 150) canvas.height = 200; 
                    }
                }
                // Appel initial et au redimensionnement
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);

                // Styles du trait
                ctx.strokeStyle = "#000000";
                ctx.lineJoin = "round";
                ctx.lineCap = "round";
                ctx.lineWidth = 2;

                function draw(e) {
                    if (!isDrawing) return;
                    e.preventDefault(); // EmpÃªcher le scroll sur mobile

                    // CoordonnÃ©es (Souris vs Touch)
                    var clientX = e.clientX;
                    var clientY = e.clientY;
                    if (e.touches && e.touches.length > 0) {
                        clientX = e.touches[0].clientX;
                        clientY = e.touches[0].clientY;
                    }

                    var rect = canvas.getBoundingClientRect();
                    var x = clientX - rect.left;
                    var y = clientY - rect.top;

                    ctx.beginPath();
                    ctx.moveTo(lastX, lastY);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                    [lastX, lastY] = [x, y];
                }

                // Ã‰vÃ©nements Souris
                canvas.addEventListener('mousedown', (e) => {
                    isDrawing = true;
                    var rect = canvas.getBoundingClientRect();
                    [lastX, lastY] = [e.clientX - rect.left, e.clientY - rect.top];
                });
                canvas.addEventListener('mousemove', draw);
                canvas.addEventListener('mouseup', () => isDrawing = false);
                canvas.addEventListener('mouseout', () => isDrawing = false);

                // Ã‰vÃ©nements Tactiles (Mobile)
                canvas.addEventListener('touchstart', (e) => {
                    isDrawing = true;
                    var rect = canvas.getBoundingClientRect();
                    var touch = e.touches[0];
                    [lastX, lastY] = [touch.clientX - rect.left, touch.clientY - rect.top];
                }, { passive: false });
                canvas.addEventListener('touchmove', draw, { passive: false });
                canvas.addEventListener('touchend', () => isDrawing = false);
            },

            clear: function (canvasId) {
                var canvas = document.getElementById(canvasId);
                if (canvas) {
                    var ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            },

            getImage: function (canvasId) {
                var canvas = document.getElementById(canvasId);
                // Retourne l'image en Base64 (PNG)
                return canvas ? canvas.toDataURL("image/png") : null;
            }
        };
    </script>
	


    <script>
        window.vehicleSchemaEditor = {
            canvas: null,
            ctx: null,
            img: null,
            
            // DonnÃ©es (Nouveaux / Editables)
            points: [],
            strokes: [],
            
            // DonnÃ©es (Origine / ReadOnly)
            originalPoints: [],
            originalStrokes: [],
            
            // Viewport
            scale: 1,
            offsetX: 0,
            offsetY: 0,
            isDragging: false,
            startX: 0,
            startY: 0,

            // Gestion du Pinch-to-Zoom (Tactile)
            lastTouchDist: 0,

            // Outils
            currentTool: 'hand', 
            isDrawing: false,
            currentStroke: [],
            readOnly: false,

            init: function (canvasId, imageUrl, jsonPoints, jsonStrokes, originalJsonPoints, originalJsonStrokes, isReadOnly) {
                this.canvas = document.getElementById(canvasId);
                if (!this.canvas) return;
                this.ctx = this.canvas.getContext('2d');
                // Handle overloading: if originalJsonPoints is boolean, it's global readOnly (old signature)
                if (typeof originalJsonPoints === 'boolean') {
                    this.readOnly = originalJsonPoints;
                    this.originalPoints = [];
                    this.originalStrokes = [];
                } else {
                    this.readOnly = isReadOnly;
                    try {
                        this.originalPoints = originalJsonPoints ? JSON.parse(originalJsonPoints) : [];
                        this.originalStrokes = originalJsonStrokes ? JSON.parse(originalJsonStrokes) : [];
                    } catch (e) { console.error("Error parsing originals", e); this.originalPoints=[]; this.originalStrokes=[]; }
                }

                // Reset Viewport
                this.scale = 1;
                this.offsetX = 0;
                this.offsetY = 0;

                // Chargement donnÃ©es
                try {
                    this.points = jsonPoints ? JSON.parse(jsonPoints) : [];
                    this.strokes = jsonStrokes ? JSON.parse(jsonStrokes) : [];
                } catch (e) { console.error(e); }

                // Chargement Image
                this.img = new Image();
                this.img.onload = () => {
                    this.fitToScreen();
                };
                this.img.src = imageUrl;

                // Events (Nettoyage et Ajout)
                this.cleanupEvents();
                this.setupEvents();
                
                // Outil par dÃ©faut
                this.setTool(this.readOnly ? 'hand' : 'pen');
            },

            fitToScreen: function() {
                if(!this.canvas || !this.img) return;
                var parent = this.canvas.parentElement;
                this.canvas.width = parent.clientWidth;
                this.canvas.height = parent.clientHeight || 500;

                var ratio = Math.min(this.canvas.width / this.img.width, this.canvas.height / this.img.height);
                this.scale = ratio * 0.95; // Marge 5%
                // Centrer
                this.offsetX = (this.canvas.width - this.img.width * this.scale) / 2;
                this.offsetY = (this.canvas.height - this.img.height * this.scale) / 2;
                this.draw();
            },

            setTool: function(tool) {
                this.currentTool = tool;
                this.canvas.style.cursor = tool === 'hand' ? 'grab' : 'crosshair';
            },

            // Zoom centrÃ© ou zoom manuel
            zoom: function(delta, centerX, centerY) {
                var factor = delta > 0 ? 1.1 : 0.9;
                
                // Si pas de centre fourni, on zoom au centre du canvas
                if (centerX === undefined) {
                    centerX = this.canvas.width / 2;
                    centerY = this.canvas.height / 2;
                }

                // Calcul pour zoomer vers le point de la souris/doigts
                var dx = (centerX - this.offsetX) / this.scale;
                var dy = (centerY - this.offsetY) / this.scale;

                this.scale *= factor;

                this.offsetX = centerX - dx * this.scale;
                this.offsetY = centerY - dy * this.scale;

                this.draw();
            },

            draw: function () {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.save();
                
                this.ctx.translate(this.offsetX, this.offsetY);
                this.ctx.scale(this.scale, this.scale);

                if (this.img) this.ctx.drawImage(this.img, 0, 0);

                // --- DESSIN ORIGINAUX (Orange - ReadOnly) ---
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.ctx.lineWidth = 5 / this.scale; 

                // Rayures
                this.originalStrokes.forEach(stroke => this.drawStrokePath(stroke, 'orange'));

                // Points
                var pointRadius = 8 / this.scale; 
                this.ctx.fillStyle = 'rgba(255, 165, 0, 0.6)'; // Orange
                this.ctx.strokeStyle = 'darkorange';
                this.ctx.lineWidth = 2 / this.scale;

                this.originalPoints.forEach(p => {
                    var x = p.X * this.img.width;
                    var y = p.Y * this.img.height;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, pointRadius, 0, 2 * Math.PI);
                    this.ctx.fill();
                    this.ctx.stroke();
                });

                // --- DESSIN NOUVEAUX (Red - Editable) ---
                this.ctx.lineWidth = 5 / this.scale; 
                this.strokes.forEach(stroke => this.drawStrokePath(stroke, 'red'));
                if (this.currentStroke.length > 0) this.drawStrokePath(this.currentStroke, 'red');

                // Points
                this.ctx.fillStyle = 'rgba(255, 0, 0, 0.6)';
                this.ctx.strokeStyle = 'red';
                this.ctx.lineWidth = 2 / this.scale;

                this.points.forEach(p => {
                    var x = p.X * this.img.width;
                    var y = p.Y * this.img.height;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, pointRadius, 0, 2 * Math.PI);
                    this.ctx.fill();
                    this.ctx.stroke();
                });

                this.ctx.restore();
            },

            drawStrokePath: function(points, color) {
                if (points.length < 2) return;
                this.ctx.strokeStyle = color;
                this.ctx.beginPath();
                this.ctx.moveTo(points[0].X * this.img.width, points[0].Y * this.img.height);
                for (let i = 1; i < points.length; i++) {
                    this.ctx.lineTo(points[i].X * this.img.width, points[i].Y * this.img.height);
                }
                this.ctx.stroke();
            },

            cleanupEvents: function() {
                var el = this.canvas;
                var elClone = el.cloneNode(true);
                el.parentNode.replaceChild(elClone, el);
                this.canvas = elClone;
                this.ctx = this.canvas.getContext('2d');
            },

            setupEvents: function() {
                // --- SOURIS & TOUCH (UnifiÃ©s) ---
                const getPos = (e) => {
                    var rect = this.canvas.getBoundingClientRect();
                    var clientX = e.clientX;
                    var clientY = e.clientY;
                    if (e.touches && e.touches.length > 0) {
                        clientX = e.touches[0].clientX;
                        clientY = e.touches[0].clientY;
                    }
                    return { x: clientX - rect.left, y: clientY - rect.top };
                };

                const toImgCoords = (x, y) => {
                    var imgX = (x - this.offsetX) / this.scale;
                    var imgY = (y - this.offsetY) / this.scale;
                    return { X: imgX / this.img.width, Y: imgY / this.img.height };
                };

                const start = (e) => {
                    if (e.touches && e.touches.length === 2) {
                        // DÃ©but du Pinch (2 doigts)
                        e.preventDefault();
                        this.isDragging = false;
                        this.isDrawing = false;
                        var t1 = e.touches[0];
                        var t2 = e.touches[1];
                        this.lastTouchDist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
                        return;
                    }

                    var pos = getPos(e);
                    
                    // Clic droit ou outil Main -> Pan
                    if (e.button === 2 || this.currentTool === 'hand') {
                        e.preventDefault(); // EmpÃªcher menu contextuel
                        this.isDragging = true;
                        this.startX = pos.x - this.offsetX;
                        this.startY = pos.y - this.offsetY;
                        this.canvas.style.cursor = 'grabbing';
                    } 
                    else if (this.currentTool === 'pen' && !this.readOnly) {
                        e.preventDefault(); // EmpÃªcher scroll mobile
                        this.isDrawing = true;
                        this.currentStroke = [toImgCoords(pos.x, pos.y)];
                    } 
                    else if (this.currentTool === 'eraser' && !this.readOnly) {
                        e.preventDefault();
                        this.eraseAt(pos.x, pos.y);
                    }
                };

                const move = (e) => {
                    e.preventDefault();

                    // Gestion Pinch-to-Zoom (2 doigts)
                    if (e.touches && e.touches.length === 2) {
                        var t1 = e.touches[0];
                        var t2 = e.touches[1];
                        var dist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
                        
                        // Centre du pinch
                        var rect = this.canvas.getBoundingClientRect();
                        var centerX = ((t1.clientX + t2.clientX) / 2) - rect.left;
                        var centerY = ((t1.clientY + t2.clientY) / 2) - rect.top;

                        var delta = dist - this.lastTouchDist;
                        // SensibilitÃ© rÃ©duite pour Ã©viter les sauts
                        if (Math.abs(delta) > 2) {
                            var factor = delta > 0 ? 1.02 : 0.98; 
                            this.zoomPinch(factor, centerX, centerY);
                            this.lastTouchDist = dist;
                        }
                        return;
                    }

                    var pos = getPos(e);

                    if (this.isDragging) {
                        this.offsetX = pos.x - this.startX;
                        this.offsetY = pos.y - this.startY;
                        this.draw();
                    } else if (this.isDrawing && this.currentTool === 'pen') {
                        this.currentStroke.push(toImgCoords(pos.x, pos.y));
                        this.draw();
                    } else if (this.currentTool === 'eraser' && e.buttons === 1) {
                        this.eraseAt(pos.x, pos.y);
                    }
                };

                const end = (e) => {
                    e.preventDefault();
                    if (this.isDragging) {
                        this.isDragging = false;
                        this.canvas.style.cursor = this.currentTool === 'hand' ? 'grab' : 'crosshair';
                    }
                    if (this.isDrawing && this.currentTool === 'pen') {
                        var pStart = this.currentStroke[0];
                        var pEnd = this.currentStroke[this.currentStroke.length - 1];
                        var dist = Math.sqrt(Math.pow(pEnd.X - pStart.X, 2) + Math.pow(pEnd.Y - pStart.Y, 2));
                        
                        if (dist < 0.01) { this.points.push(pStart); } 
                        else { this.strokes.push(this.currentStroke); }
                        
                        this.currentStroke = [];
                        this.draw();
                    }
                    this.isDrawing = false;
                };

                // Molette de souris (Zoom)
                const wheel = (e) => {
                    e.preventDefault();
                    var pos = getPos(e);
                    var delta = e.deltaY < 0 ? 1 : -1;
                    this.zoom(delta, pos.x, pos.y);
                };

                this.canvas.addEventListener('mousedown', start);
                this.canvas.addEventListener('mousemove', move);
                this.canvas.addEventListener('mouseup', end);
                // Sortie de zone
                this.canvas.addEventListener('mouseleave', end);
                
                // Support Tactile
                this.canvas.addEventListener('touchstart', start, { passive: false });
                this.canvas.addEventListener('touchmove', move, { passive: false });
                this.canvas.addEventListener('touchend', end, { passive: false });
                
                // Support Molette
                this.canvas.addEventListener('wheel', wheel, { passive: false });
                // DÃ©sactiver menu contextuel (clic droit pour pan)
                this.canvas.addEventListener('contextmenu', e => e.preventDefault());
            },

            zoomPinch: function(factor, cx, cy) {
                var dx = (cx - this.offsetX) / this.scale;
                var dy = (cy - this.offsetY) / this.scale;
                this.scale *= factor;
                this.offsetX = cx - dx * this.scale;
                this.offsetY = cy - dy * this.scale;
                this.draw();
            },

            eraseAt: function(screenX, screenY) {
                var clickPos = { 
                    X: ((screenX - this.offsetX) / this.scale) / this.img.width, 
                    Y: ((screenY - this.offsetY) / this.scale) / this.img.height 
                };
                // Seuil plus grand quand on est dÃ©zoomÃ© pour faciliter la gomme
                var threshold = (20 / this.scale) / this.img.width; 

                // Effacer points
                for (let i = this.points.length - 1; i >= 0; i--) {
                    var p = this.points[i];
                    var dist = Math.sqrt(Math.pow(p.X - clickPos.X, 2) + Math.pow(p.Y - clickPos.Y, 2));
                    if (dist < threshold) {
                        this.points.splice(i, 1);
                        this.draw();
                        return;
                    }
                }
                // Effacer rayures
                for (let i = this.strokes.length - 1; i >= 0; i--) {
                    var stroke = this.strokes[i];
                    for (let p of stroke) {
                         var dist = Math.sqrt(Math.pow(p.X - clickPos.X, 2) + Math.pow(p.Y - clickPos.Y, 2));
                         if (dist < threshold) {
                             this.strokes.splice(i, 1);
                             this.draw();
                             return;
                         }
                    }
                }
            },
            
            getData: function() {
                return JSON.stringify({
                    points: JSON.stringify(this.points),
                    strokes: JSON.stringify(this.strokes)
                });
            }
        };
    </script>
	
</body>
</html>