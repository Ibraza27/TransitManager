@using Microsoft.AspNetCore.SignalR.Client
@using TransitManager.Core.Entities
@using TransitManager.Core.Enums
@using Microsoft.AspNetCore.Http 
@inject IApiService ApiService
@inject NavigationManager Navigation
@inject AuthenticationStateProvider AuthStateProvider
@inject IConfiguration Configuration
@inject IJSRuntime JSRuntime
@inject ILocalStorageService LocalStorage
@inject IHttpContextAccessor HttpContextAccessor 
@implements IAsyncDisposable

<div class="dropdown">
    <!-- Bouton Cloche -->
    <button class="btn btn-link text-primary position-relative p-0 me-3" 
            type="button" 
            id="notifDropdown" 
            data-bs-toggle="dropdown" 
            aria-expanded="false" 
            @onclick="ToggleDropdown">
        <i class="bi bi-bell-fill fs-5"></i>
        
        @if (_unreadCount > 0)
        {
            <span class="position-absolute top-0 start-100 translate-middle badge rounded-pill bg-danger border border-light" 
                  style="font-size: 0.6rem; animation: pulse 2s infinite;">
                @(_unreadCount > 99 ? "99+" : _unreadCount)
            </span>
        }
    </button>
    
    <!-- Menu DÃ©roulant -->
    <div class="dropdown-menu dropdown-menu-end shadow-lg p-0 border-0 @(_isOpen ? "show" : "")" 
         style="width: 380px; max-height: 500px; overflow-y: auto; right: 0; left: auto; z-index: 9999 !important; position: fixed; top: 60px;">
        
        <div class="p-3 border-bottom d-flex justify-content-between align-items-center bg-primary text-white sticky-top">
            <h6 class="mb-0 fw-bold"><i class="bi bi-bell me-2"></i>Notifications</h6>
            @if (_notifications.Any(n => !n.EstLue))
            {
                <button class="btn btn-sm btn-light text-primary fw-bold py-0" @onclick="MarkAllRead" @onclick:stopPropagation="true">
                    <small>Tout lire</small>
                </button>
            }
        </div>

        @if (_isLoading)
        {
            <div class="text-center p-4 text-muted">
                <div class="spinner-border spinner-border-sm mb-2"></div>
                <p class="mb-0 small">Chargement...</p>
            </div>
        }
        else if (_notifications == null || !_notifications.Any())
        {
            <div class="text-center p-5 text-muted">
                <i class="bi bi-bell-slash fs-1 d-block mb-3 opacity-25"></i>
                <span>Aucune notification.</span>
            </div>
        }
        else
        {
            <div class="list-group list-group-flush">
                @foreach (var notif in _notifications)
                {
                    <div class="list-group-item list-group-item-action p-3 border-bottom @(!notif.EstLue ? "bg-blue-50" : "")" 
                         style="cursor: pointer;" 
                         @onclick="() => HandleClick(notif)">
                        
                        <div class="d-flex">
                            <div class="me-3 mt-1 position-relative">
                                <div class="rounded-circle d-flex align-items-center justify-content-center @GetIconBackgroundClass(notif.Categorie)" style="width: 40px; height: 40px;">
                                    <i class="bi @notif.Icone fs-5 text-white"></i>
                                </div>
                                @if (!notif.EstLue)
                                {
                                    <span class="position-absolute top-0 start-100 translate-middle p-1 bg-danger border border-light rounded-circle"></span>
                                }
                            </div>
                            
                            <div class="flex-grow-1">
                                <div class="d-flex justify-content-between align-items-start mb-1">
                                    <strong class="small @(!notif.EstLue ? "fw-bold text-dark" : "text-secondary")">@notif.Title</strong>
                                    <small class="text-muted ms-2" style="font-size: 0.7rem; white-space: nowrap;">@GetTimeAgo(notif.DateCreation)</small>
                                </div>
                                <p class="mb-0 small text-secondary text-break lh-sm">@notif.Message</p>
                            </div>
                        </div>
                    </div>
                }
            </div>
        }
    </div>
    
    <!-- Overlay de fermeture -->
    @if (_isOpen)
    {
        <div style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1040;" @onclick="CloseDropdown"></div>
    }
</div>

<!-- TOASTS -->
<div class="toast-container position-fixed bottom-0 end-0 p-3" style="z-index: 1100">
    @foreach (var toast in _activeToasts)
    {
        <div class="toast show shadow-lg border-0 mb-2 fade-in-up" role="alert">
            <div class="toast-header @GetIconBackgroundClass(toast.Categorie) text-white">
                <i class="bi @toast.Icone me-2"></i>
                <strong class="me-auto">@toast.Title</strong>
                <small>Ã€ l'instant</small>
                <button type="button" class="btn-close btn-close-white" @onclick="() => RemoveToast(toast)"></button>
            </div>
            <div class="toast-body bg-white cursor-pointer" @onclick="() => HandleClick(toast)">
                @toast.Message
            </div>
        </div>
    }
</div>

<style>
    .bg-blue-50 { background-color: #f0f7ff; }
    .fade-in-up { animation: fadeInUp 0.3s ease-out; }
    @@keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    @@keyframes pulse { 0% { transform: scale(1) translate(-50%, -50%); } 50% { transform: scale(1.2) translate(-50%, -50%); } 100% { transform: scale(1) translate(-50%, -50%); } }
</style>

@code {
    private List<Notification> _notifications = new();
    private int _unreadCount = 0;
    private bool _isLoading = false;
    private bool _isOpen = false;
    private HubConnection? _hubConnection;
    private List<Notification> _activeToasts = new();
    private bool _isConnected = false;

    // On Ã©vite le SSR (Server Side Rendering) pour SignalR
    protected override void OnInitialized() { }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await LoadUnreadCount();
            await ConnectSignalR();
        }
    }

    private async Task ConnectSignalR()
    {
        if (_isConnected) return;

        try 
        {
            // RÃ©cupÃ©ration de l'URL
            var apiBaseUrl = Configuration["ApiBaseUrl"] ?? "https://localhost:7243"; 
            var hubUrl = $"{apiBaseUrl}/notificationHub";

            // RÃ©cupÃ©ration du Cookie
            var httpContext = HttpContextAccessor.HttpContext;
            string? cookieValue = null;
            if (httpContext != null)
            {
                cookieValue = httpContext.Request.Cookies["TransitManager.AuthCookie"] 
                           ?? httpContext.Request.Cookies[".AspNetCore.Cookies"];
            }

            _hubConnection = new HubConnectionBuilder()
                .WithUrl(hubUrl, options => {
                    
                    // 1. Injection du Cookie (Essentiel)
                    if (!string.IsNullOrEmpty(cookieValue))
                    {
                        if (options.Headers == null) options.Headers = new Dictionary<string, string>();
                        // On nettoie le cookie pour Ã©viter les doublons ou caractÃ¨res invalides
                        var cleanCookie = cookieValue.Split(';')[0].Trim(); 
                        options.Headers["Cookie"] = $"TransitManager.AuthCookie={cleanCookie}";
                    }

                    // 2. STABILITÃ‰ : On autorise le repli sur LongPolling si WebSocket Ã©choue
                    // C'est souvent ce qui sauve la connexion sur des rÃ©seaux complexes/VPN
                    options.Transports = Microsoft.AspNetCore.Http.Connections.HttpTransportType.WebSockets | 
                                         Microsoft.AspNetCore.Http.Connections.HttpTransportType.LongPolling;
                    
                    // 3. IMPORTANT : On rÃ©active la nÃ©gociation pour que le SSL bypass s'applique correctement dÃ¨s le dÃ©but
                    options.SkipNegotiation = false;

                    // 4. Bypass SSL (Indispensable pour l'IP 100.x.x.x et localhost)
                    options.HttpMessageHandlerFactory = (handler) => {
                        if (handler is HttpClientHandler clientHandler)
                        {
                            clientHandler.ServerCertificateCustomValidationCallback = (m, c, ch, e) => true;
                        }
                        return handler;
                    };
                })

                // Reconnexion automatique INFINIE (Custom Policy)
                .WithAutomaticReconnect(new InfiniteRetryPolicy())
                .Build();

            // Gestion de la visibilitÃ© de page pour reconnexion immÃ©diate sur Mobile
            await JSRuntime.InvokeVoidAsync("eval", @"
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'visible' && window.signalRConnection && window.signalRConnection.state === 'Disconnected') {
                        console.log('ðŸ”„ [App] Retour sur l\'onglet : Tentative de reconnexion immÃ©diate...');
                        window.signalRConnection.start();
                    }
                });
            ");
            // Exposer la connexion globalement pour le script ci-dessus
             await JSRuntime.InvokeVoidAsync("eval", "window.signalRConnection = null;"); 

            // Timeouts Ã©tendus
            _hubConnection.ServerTimeout = TimeSpan.FromMinutes(4);
            _hubConnection.HandshakeTimeout = TimeSpan.FromSeconds(30);

            // Gestion des messages
            _hubConnection.On<object>("ReceiveNotification", async (obj) =>
            {
                await InvokeAsync(async () => 
                {
                    _unreadCount++;
                    if (_isOpen) await LoadNotifications();
                    else 
                    {
                         await Task.Delay(500); // Petit dÃ©lai pour la BDD
                         var latestList = await ApiService.GetMyNotificationsAsync();
                         var latest = latestList.FirstOrDefault();
                         if (latest != null && !_activeToasts.Any(t => t.Id == latest.Id)) ShowToast(latest);
                    }
                    StateHasChanged();
                });
            });

            _hubConnection.On<Guid>("NotificationDeleted", async (id) =>
            {
                await InvokeAsync(() =>
                {
                    var notif = _notifications.FirstOrDefault(n => n.Id == id);
                    if (notif != null)
                    {
                        _notifications.Remove(notif);
                        if (!notif.EstLue) _unreadCount--;
                        StateHasChanged();
                    }
                });
            });

            _hubConnection.Closed += async (error) => 
            {
                _isConnected = false;
                Console.WriteLine($"âš ï¸ [Notif] SignalR fermÃ© : {error?.Message}");
                await InvokeAsync(StateHasChanged);
            };

            _hubConnection.Reconnected += (id) =>
            {
                _isConnected = true;
                Console.WriteLine($"âœ… [Notif] SignalR ReconnectÃ© !");
                return Task.CompletedTask;
            };

            Console.WriteLine($"ðŸš€ [Notif] Tentative connexion SignalR vers {hubUrl}...");
            await _hubConnection.StartAsync();
            // Exposer pour le script de visibilitÃ©
             await JSRuntime.InvokeVoidAsync("eval", "window.signalRConnection = arguments[0];", _hubConnection);
            _isConnected = true;
            Console.WriteLine($"âœ… [Notif] ConnectÃ© !");
        }
        catch (Exception ex)
        {
            _isConnected = false;
            Console.WriteLine($"âŒ [Notif] Erreur Connexion : {ex.Message}");
        }
    }
	
    private async Task LoadUnreadCount()
    {
        try {
            _unreadCount = await ApiService.GetUnreadNotificationsCountAsync();
            await InvokeAsync(StateHasChanged);
        } catch {}
    }

    private void ToggleDropdown()
    {
        _isOpen = !_isOpen;
        if (_isOpen) _ = LoadNotifications();
    }

    private void CloseDropdown() => _isOpen = false;

    private async Task LoadNotifications()
    {
        _isLoading = true;
        await InvokeAsync(StateHasChanged); 
        try {
            _notifications = (await ApiService.GetMyNotificationsAsync()).ToList();
            _unreadCount = _notifications.Count(n => !n.EstLue);
        } catch {}
        _isLoading = false;
        await InvokeAsync(StateHasChanged);
    }

    private async Task MarkAllRead()
    {
        await ApiService.MarkAllNotificationsAsReadAsync();
        foreach (var n in _notifications) n.EstLue = true;
        _unreadCount = 0;
        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleClick(Notification notif)
    {
        if (!notif.EstLue) {
            notif.EstLue = true;
            if (_unreadCount > 0) _unreadCount--;
            _ = ApiService.MarkNotificationAsReadAsync(notif.Id);
        }
        RemoveToast(notif);
        _isOpen = false;
        if (!string.IsNullOrEmpty(notif.ActionUrl)) Navigation.NavigateTo(notif.ActionUrl);
    }

    private void ShowToast(Notification notif)
    {
        _activeToasts.Add(notif);
        InvokeAsync(StateHasChanged);
        var timer = new System.Timers.Timer(5000);
        timer.Elapsed += (s, e) => { RemoveToast(notif); timer.Dispose(); };
        timer.Start();
    }
    
    private void RemoveToast(Notification n) {
        if(_activeToasts.Contains(n)) {
            _activeToasts.Remove(n);
            InvokeAsync(StateHasChanged);
        }
    }

    private string GetTimeAgo(DateTime date)
    {
        var span = DateTime.UtcNow - date.ToUniversalTime();
        if (span.TotalMinutes < 1) return "Ã€ l'instant";
        if (span.TotalMinutes < 60) return $"Il y a {(int)span.TotalMinutes} min";
        if (span.TotalHours < 24) return $"Il y a {(int)span.TotalHours} h";
        return date.ToLocalTime().ToString("dd/MM");
    }

    private string GetIconBackgroundClass(CategorieNotification cat) => cat switch
    {
        CategorieNotification.StatutColis => "bg-primary",
        CategorieNotification.StatutVehicule => "bg-info",
        CategorieNotification.StatutConteneur => "bg-indigo",
        CategorieNotification.Paiement => "bg-success",
        CategorieNotification.AlerteDouane => "bg-danger",
        CategorieNotification.NouveauMessage => "bg-warning",
        _ => "bg-secondary"
    };

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection != null) await _hubConnection.DisposeAsync();
    }

    public class InfiniteRetryPolicy : IRetryPolicy
    {
        public TimeSpan? NextRetryDelay(RetryContext retryContext)
        {
            // Backoff progressif : 0s, 2s, 4s, ..., max 30s
            // Et on ne renvoie jamais null => Infini
            var delay = retryContext.PreviousRetryCount * 2;
            if (delay > 30) delay = 30; 
            return TimeSpan.FromSeconds(delay == 0 ? 0 : delay);
        }
    }
}